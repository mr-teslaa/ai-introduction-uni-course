To solve the maze pathfinding problem, we will implement Depth-first search (DFS), Breadth-first search (BFS), and A* search algorithms. Let's first start by reading the maze from the input file and storing it in a two-dimensional array.
Here's the implementation in Python:
import sys
import math

# Define the directions in which we can move
directions = {
    "up": (-1, 0),
    "right": (0, 1),
    "down": (1, 0),
    "left": (0, -1),
}

# Read the maze from stdin
maze = []
for line in sys.stdin:
    maze.append([int(x) for x in line.strip().split()])

# Define a helper function to get the neighbors of a cell
def get_neighbors(cell):
    neighbors = []
    for direction in directions.values():
        neighbor = (cell[0] + direction[0], cell[1] + direction[1])
        if (
            0 <= neighbor[0] < len(maze)
            and 0 <= neighbor[1] < len(maze[0])
            and maze[neighbor[0]][neighbor[1]] == 0
        ):
            neighbors.append(neighbor)
    return neighbors

Depth-first search
DFS is a recursive algorithm that explores as far as possible along each branch before backtracking. We will implement it using a recursive function that takes the current cell as an argument.
Here's the implementation in Python:
# Define the DFS function
def dfs(cell):
    maze[cell[0]][cell[1]] = 2  # mark the cell as visited
    if cell[0] == 0:
        return True  # we have reached the top of the maze
    for neighbor in get_neighbors(cell):
        if dfs(neighbor):
            maze[neighbor[0]][neighbor[1]] = 5  # mark the cell as part of the solution path
            return True  # we have found a path to the top of the maze
    return False  # we have not found a path to the top of the maze

# Start DFS from the entrance of the maze
dfs((len(maze)-1, maze[len(maze)-1].index(0)))

# Output the maze with the solution path
for row in maze:
    print(" ".join(str(x) for x in row))

Breadth-first search
BFS is an algorithm that explores the neighbor cells first, before moving to the next level of cells. We will implement it using a queue to keep track of the cells to explore.
Here's the implementation in Python:
# Define the BFS function
def bfs(start):
    queue = [start]  # initialize the queue with the starting cell
    while queue:
        cell = queue.pop(0)
        maze[cell[0]][cell[1]] = 2  # mark the cell as visited
        if cell[0] == 0:
            return True  # we have reached the top of the maze
        for neighbor in get_neighbors(cell):
            queue.append(neighbor)  # add the neighbor to the queue
    return False  # we have not found a path to the top of the maze

# Start BFS from the entrance of the maze
bfs((len(maze)-1, maze[len(maze)-1].index(0)))

# Output the maze with the solution path
for row in maze:
    print(" ".join(str(x) for x in row))
``

here's an implementation of A* search algorithm for the given maze problem:
import heapq
import math
import sys

# Define the maze dimensions
MAZE_WIDTH = 10
MAZE_HEIGHT = 10

# Define the movement directions - up, right, left, down
directions = [(0, -1), (1, 0), (-1, 0), (0, 1)]

# Define the heuristic function using the L2 (Euclidean) norm
def heuristic(a, b):
    return math.sqrt((b[0] - a[0]) ** 2 + (b[1] - a[1]) ** 2)

# Define the A* search function
def astar(maze, start, goal):
    frontier = []
    heapq.heappush(frontier, (0, start))
    came_from = {}
    cost_so_far = {}
    came_from[start] = None
    cost_so_far[start] = 0
    
    while len(frontier) > 0:
        current = heapq.heappop(frontier)[1]
        
        if current == goal:
            break
        
        for direction in directions:
            dx, dy = direction
            next_pos = (current[0] + dx, current[1] + dy)
            
            if next_pos[0] < 0 or next_pos[0] >= MAZE_WIDTH or next_pos[1] < 0 or next_pos[1] >= MAZE_HEIGHT:
                continue
                
            if maze[next_pos[1]][next_pos[0]] == 1:
                continue
                
            new_cost = cost_so_far[current] + 1
            if next_pos not in cost_so_far or new_cost < cost_so_far[next_pos]:
                cost_so_far[next_pos] = new_cost
                priority = new_cost + heuristic(goal, next_pos)
                heapq.heappush(frontier, (priority, next_pos))
                came_from[next_pos] = current
                
    # Reconstruct the path from start to goal
    path = []
    current = goal
    while current != start:
        path.append(current)
        current = came_from[current]
    path.append(start)
    path.reverse()
    
    # Mark the visited cells with 2 and the path cells with 5
    for position in came_from:
        if position != start:
            maze[position[1]][position[0]] = 2
    for position in path:
        maze[position[1]][position[0]] = 5
        
    # Return the resulting maze and the path
    return maze, path

# Read the maze from stdin
maze = []
for i in range(MAZE_HEIGHT):
    maze.append([int(x) for x in input().strip().split()])

# Find the start and goal positions
start = (0, MAZE_HEIGHT - 1)
goal = (MAZE_WIDTH - 1, 0)

# Run the A* search algorithm on the maze
resulting_maze, path = astar(maze, start, goal)

# Print the resulting maze and the path
for i in range(MAZE_HEIGHT):
    for j in range(MAZE_WIDTH):
        print(resulting_maze[i][j], end=' ')
    print()
print("Path:", path)
